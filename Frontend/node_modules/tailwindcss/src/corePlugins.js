import fs from 'fs'
import * as path from 'path'
import postcss from 'postcss'
import createUtilityPlugin from './util/createUtilityPlugin'
import buildMediaQuery from './util/buildMediaQuery'
import escapeClassName from './util/escapeClassName'
import parseAnimationValue from './util/parseAnimationValue'
import flattenColorPalette from './util/flattenColorPalette'
import withAlphaVariable, { withAlphaValue } from './util/withAlphaVariable'
import toColorValue from './util/toColorValue'
import isPlainObject from './util/isPlainObject'
import transformThemeValue from './util/transformThemeValue'
import { version as tailwindVersion } from '../package.json'
import log from './util/log'
import {
  normalizeScreens,
  isScreenSortable,
  compareScreens,
  toScreen,
} from './util/normalizeScreens'
import { formatBoxShadowValue, parseBoxShadowValue } from './util/parseBoxShadowValue'
import { removeAlphaVariables } from './util/removeAlphaVariables'
import { flagEnabled } from './featureFlags'
import { normalize, normalizeAttributeSelectors } from './util/dataTypes'
import { INTERNAL_FEATURES } from './lib/setupContextUtils'

export let variantPlugins = {
  childVariant: ({ addVariant }) => {
    addVariant('*', '& > *')
  },
  pseudoElementVariants: ({ addVariant }) => {
    addVariant('first-letter', '&::first-letter')
    addVariant('first-line', '&::first-line')

    addVariant('marker', [
      ({ container }) => {
        removeAlphaVariables(container, ['--tw-text-opacity'])

        return '& *::marker'
      },
      ({ container }) => {
        removeAlphaVariables(container, ['--tw-text-opacity'])

        return '&::marker'
      },
    ])

    addVariant('selection', ['& *::selection', '&::selection'])

    addVariant('file', '&::file-selector-button')

    addVariant('placeholder', '&::placeholder')

    addVariant('backdrop', '&::backdrop')

    addVariant('before', ({ container }) => {
      container.walkRules((rule) => {
        let foundContent = false
        rule.walkDecls('content', () => {
          foundContent = true
        })

        if (!foundContent) {
          rule.prepend(postcss.decl({ prop: 'content', value: 'var(--tw-content)' }))
        }
      })

      return '&::before'
    })

    addVariant('after', ({ container }) => {
      container.walkRules((rule) => {
        let foundContent = false
        rule.walkDecls('content', () => {
          foundContent = true
        })

        if (!foundContent) {
          rule.prepend(postcss.decl({ prop: 'content', value: 'var(--tw-content)' }))
        }
      })

      return '&::after'
    })
  },

  pseudoClassVariants: ({ addVariant, matchVariant, config, prefix }) => {
    let pseudoVariants = [
      // Positional
      ['first', '&:first-child'],
      ['last', '&:last-child'],
      ['only', '&:only-child'],
      ['odd', '&:nth-child(odd)'],
      ['even', '&:nth-child(even)'],
      'first-of-type',
      'last-of-type',
      'only-of-type',

      // State
      [
        'visited',
        ({ container }) => {
          removeAlphaVariables(container, [
            '--tw-text-opacity',
            '--tw-border-opacity',
            '--tw-bg-opacity',
          ])

          return '&:visited'
        },
      ],
      'target',
      ['open', '&[open]'],

      // Forms
      'default',
      'checked',
      'indeterminate',
      'placeholder-shown',
      'autofill',
      'optional',
      'required',
      'valid',
      'invalid',
      'in-range',
      'out-of-range',
      'read-only',

      // Content
      'empty',

      // Interactive
      'focus-within',
      [
        'hover',
        !flagEnabled(config(), 'hoverOnlyWhenSupported')
          ? '&:hover'
          : '@media (hover: hover) and (pointer: fine) { &:hover }',
      ],
      'focus',
      'focus-visible',
      'active',
      'enabled',
      'disabled',
    ].map((variant) => (Array.isArray(variant) ? variant : [variant, `&:${variant}`]))

    for (let [variantName, state] of pseudoVariants) {
      addVariant(variantName, (ctx) => {
        let result = typeof state === 'function' ? state(ctx) : state

        return result
      })
    }

    let variants = {
      group: (_, { modifier }) =>
        modifier
          ? [`:merge(${prefix('.group')}\\/${escapeClassName(modifier)})`, ' &']
          : [`:merge(${prefix('.group')})`, ' &'],
      peer: (_, { modifier }) =>
        modifier
          ? [`:merge(${prefix('.peer')}\\/${escapeClassName(modifier)})`, ' ~ &']
          : [`:merge(${prefix('.peer')})`, ' ~ &'],
    }

    for (let [name, fn] of Object.entries(variants)) {
      matchVariant(
        name,
        (value = '', extra) => {
          let result = normalize(typeof value === 'function' ? value(extra) : value)
          if (!result.includes('&')) result = '&' + result

          let [a, b] = fn('', extra)

          let start = null
          let end = null
          let quotes = 0

          for (let i = 0; i < result.length; ++i) {
            let c = result[i]
            if (c === '&') {
              start = i
            } else if (c === "'" || c === '"') {
              quotes += 1
            } else if (start !== null && c === ' ' && !quotes) {
              end = i
            }
          }

          if (start !== null && end === null) {
            end = result.length
          }

          // Basically this but can handle quotes:
          // result.replace(/&(\S+)?/g, (_, pseudo = '') => a + pseudo + b)

          return result.slice(0, start) + a + result.slice(start + 1, end) + b + result.slice(end)
        },
        {
          values: Object.fromEntries(pseudoVariants),
          [INTERNAL_FEATURES]: {
            respectPrefix: false,
          },
        }
      )
    }
  },

  directionVariants: ({ addVariant }) => {
    addVariant('ltr', '&:where([dir="ltr"], [dir="ltr"] *)')
    addVariant('rtl', '&:where([dir="rtl"], [dir="rtl"] *)')
  },

  reducedMotionVariants: ({ addVariant }) => {
    addVariant('motion-safe', '@media (prefers-reduced-motion: no-preference)')
    addVariant('motion-reduce', '@media (prefers-reduced-motion: reduce)')
  },

  darkVariants: ({ config, addVariant }) => {
    let [mode, selector = '.dark'] = [].concat(config('darkMode', 'media'))

    if (mode === false) {
      mode = 'media'
      log.warn('darkmode-false', [
        'The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.',
        'Change `darkMode` to `media` or remove it entirely.',
        'https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration',
      ])
    }

    if (mode === 'variant') {
      let formats
      if (Array.isArray(selector)) {
        formats = selector
      } else if (typeof selector === 'function') {
        formats = selector
      } else if (typeof selector === 'string') {
        formats = [selector]
      }

      // TODO: We could also add these warnings if the user passes a function that returns string | string[]
      // But this is an advanced enough use case that it's probably not necessary
      if (Array.isArray(formats)) {
        for (let format of formats) {
          if (format === '.dark') {
            mode = false
            log.warn('darkmode-variant-without-selector', [
              'When using `variant` for `darkMode`, you must provide a selector.',
              'Example: `darkMode: ["variant", ".your-selector &"]`',
            ])
          } else if (!format.includes('&')) {
            mode = false
            log.warn('darkmode-variant-without-ampersand', [
              'When using `variant` for `darkMode`, your selector must contain `&`.',
              'Example `darkMode: ["variant", ".your-selector &"]`',
            ])
          }
        }
      }

      selector = formats
    }

    if (mode === 'selector') {
      // New preferred behavior
      addVariant('dark', `&:where(${selector}, ${selector} *)`)
    } else if (mode === 'media') {
      addVariant('dark', '@media (prefers-color-scheme: dark)')
    } else if (mode === 'variant') {
      addVariant('dark', selector)
    } else if (mode === 'class') {
      // Old behavior
      addVariant('dark', `&:is(${selector} *)`)
    }
  },

  printVariant: ({ addVariant }) => {
    addVariant('print', '@media print')
  },

  screenVariants: ({ theme, addVariant, matchVariant }) => {
    let rawScreens = theme('screens') ?? {}
    let areSimpleScreens = Object.values(rawScreens).every((v) => typeof v === 'string')
    let screens = normalizeScreens(theme('screens'))

    /** @type {Set<string>} */
    let unitCache = new Set([])

    /** @param {string} value */
    function units